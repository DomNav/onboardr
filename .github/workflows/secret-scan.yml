name: Secret Scan

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]
  workflow_dispatch: # Allow manual trigger

jobs:
  secret-detection:
    name: Secret Detection
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for comprehensive scanning
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
    
    # Method 1: GitGuardian CLI Scan
    - name: Install GitGuardian CLI
      run: |
        pip install detect-secrets
        # Install GitGuardian CLI if available (optional - requires token)
        # pip install gitguardian
      
    - name: Run detect-secrets scan
      run: |
        echo "üîç Running detect-secrets scan..."
        detect-secrets --version
        
        # Initialize baseline if it doesn't exist
        if [ ! -f .secrets.baseline ]; then
          echo "üìù Creating detect-secrets baseline..."
          detect-secrets scan --all-files --force-use-all-plugins \
            --exclude-files '\.git/.*|node_modules/.*|dist/.*|\.env\.example|pnpm-lock\.yaml|package-lock\.json|\.secrets\.baseline' \
            > .secrets.baseline
        fi
        
        # Audit against baseline
        echo "üîç Auditing against baseline..."
        detect-secrets audit .secrets.baseline --display-results
        
        # Scan new files since last commit
        echo "üîç Scanning for new secrets..."
        detect-secrets scan --baseline .secrets.baseline \
          --exclude-files '\.git/.*|node_modules/.*|dist/.*|\.env\.example|pnpm-lock\.yaml|package-lock\.json'
    
    # Method 2: TruffleHog Scan (Alternative/Additional)
    - name: Run TruffleHog scan
      uses: trufflesecurity/trufflehog@main
      with:
        path: ./
        base: main
        head: HEAD
        extra_args: --debug --only-verified
    
    # Method 3: Manual pattern matching for common secrets
    - name: Manual secret pattern check
      run: |
        echo "üîç Running manual pattern checks..."
        
        # Check for common secret patterns in tracked files
        echo "Checking for API keys..."
        if git ls-files | xargs grep -l "sk-[a-zA-Z0-9]\{48\}" 2>/dev/null; then
          echo "‚ùå OpenAI/Anthropic API key pattern detected!"
          exit 1
        fi
        
        if git ls-files | xargs grep -l "xoxb-[0-9]\+-[0-9]\+-[a-zA-Z0-9]\+" 2>/dev/null; then
          echo "‚ùå Slack bot token pattern detected!"
          exit 1
        fi
        
        if git ls-files | xargs grep -l "AIza[0-9A-Za-z\\-_]\{35\}" 2>/dev/null; then
          echo "‚ùå Google API key pattern detected!"
          exit 1
        fi
        
        # Check for .env files (except .env.example)
        if git ls-files | grep -E "\.env$|\.env\." | grep -v "\.env\.example"; then
          echo "‚ùå Environment files detected in repository!"
          echo "Found:"
          git ls-files | grep -E "\.env$|\.env\." | grep -v "\.env\.example"
          exit 1
        fi
        
        echo "‚úÖ Manual pattern checks passed"
    
    # Method 4: Check commit messages for secrets (paranoid mode)
    - name: Scan commit messages
      if: github.event_name == 'push'
      run: |
        echo "üîç Scanning recent commit messages..."
        
        # Get commits since last push
        COMMITS=$(git log --oneline -10 --pretty=format:"%H %s")
        
        if echo "$COMMITS" | grep -iE "(password|secret|key|token|api)" >/dev/null; then
          echo "‚ö†Ô∏è Potentially sensitive words found in commit messages:"
          echo "$COMMITS" | grep -iE "(password|secret|key|token|api)"
          echo "Please review commit messages for sensitive information"
          # Don't fail the build for this, just warn
        fi
        
        echo "‚úÖ Commit message scan completed"
    
    # Optional: GitGuardian scan (requires secret)
    - name: GitGuardian scan
      if: false  # Disabled by default - enable if you have GitGuardian API key
      env:
        GITGUARDIAN_API_KEY: ${{ secrets.GITGUARDIAN_API_KEY }}
      run: |
        if [ -n "$GITGUARDIAN_API_KEY" ]; then
          echo "üîç Running GitGuardian scan..."
          pip install gitguardian
          ggshield secret scan repo .
        else
          echo "‚ö†Ô∏è GitGuardian API key not configured, skipping GitGuardian scan"
        fi
    
    - name: Summary
      if: always()
      run: |
        echo "üîí Secret scanning completed!"
        echo "If any secrets were found, the workflow will fail."
        echo "Review the logs above for details."

  # Additional job: Verify environment setup
  env-verification:
    name: Environment Verification
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Verify .env.example files
      run: |
        echo "üîç Verifying .env.example files..."
        
        # Check if .env.example files exist
        if [ ! -f .env.example ]; then
          echo "‚ùå Missing .env.example in root"
          exit 1
        fi
        
        if [ ! -f backend/.env.example ]; then
          echo "‚ùå Missing backend/.env.example"
          exit 1
        fi
        
        # Check if they contain placeholder values
        if grep -q "your-.*-key-here" .env.example && grep -q "your-.*-key-here" backend/.env.example; then
          echo "‚úÖ .env.example files contain placeholder values"
        else
          echo "‚ùå .env.example files may contain real values!"
          exit 1
        fi
        
        echo "‚úÖ Environment verification passed"
    
    - name: Check .gitignore coverage
      run: |
        echo "üîç Verifying .gitignore coverage..."
        
        # Check if common secret patterns are ignored
        if ! grep -q "\.env$" .gitignore; then
          echo "‚ùå .env files not properly ignored"
          exit 1
        fi
        
        if ! grep -q "\*\*\/\*\.pem" .gitignore; then
          echo "‚ùå .pem files not ignored"
          exit 1
        fi
        
        echo "‚úÖ .gitignore coverage verified"